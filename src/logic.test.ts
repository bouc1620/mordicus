import { DeepReadonly } from 'ts-essentials';
import { Directions, DirectionType } from './directions';
import { StateSnapshot } from './game-state';
import { Logic } from './logic';
import { Units, UnitType } from './units';
import { GridType } from './grid';

const mockStorageGetItem = jest.fn().mockReturnValue('0');
const mockStorageSetItem = jest.fn();
global.localStorage = {
  getItem: mockStorageGetItem,
  setItem: mockStorageSetItem,
} as unknown as Storage;

type TestGridType = DeepReadonly<(UnitType | 'üêî')[][]>;

const getGridWithChickensReplaced = (grid: TestGridType, unit: UnitType): GridType =>
  grid.map((row) => row.map((u) => (u === 'üêî' ? unit : u)));

const mockState: StateSnapshot = {
  screen: 'level',
  grid: [],
  score: 0,
  bonus: 0,
  stage: 1,
  lives: 5,
  password: '123456',
  isCustom: true,
  input: '',
};

describe('isSuccess', () => {
  it('should be false if mordicus cannot be found on the grid', () => {
    expect(
      Logic.isSuccess({
        ...mockState,
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', 'ü¶ç', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ'],
        ],
      }),
    ).toBe(false);
  });

  it('should be false if there are still bananas left on the grid', () => {
    expect(
      Logic.isSuccess({
        ...mockState,
        grid: [
          ['‚¨õ', 'ü¶ç', '‚¨õ'],
          ['üçå', '‚¨õ', 'üçå'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
        ],
      }),
    ).toBe(false);
  });

  it('should be false if there are still coins left on the grid', () => {
    expect(
      Logic.isSuccess({
        ...mockState,
        grid: [
          ['‚¨õ', 'ü¶ç', '‚¨õ'],
          ['üü°', '‚¨õ', 'üü°'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
        ],
      }),
    ).toBe(false);
  });

  it('should be false if there is at least one gorilla surrounding mordicus', () => {
    expect(
      Logic.isSuccess({
        ...mockState,
        grid: [
          ['‚¨õ', 'ü¶ç', '‚¨õ'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ'],
        ],
      }),
    ).toBe(false);
  });

  it('should be true if mordicus can be found and there are no bananas or coins left on the grid', () => {
    expect(
      Logic.isSuccess({
        ...mockState,
        grid: [
          ['‚¨õ', 'ü¶ç', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
        ],
      }),
    ).toBe(true);
  });
});

describe('getActiveMoveResult', () => {
  it('should return an unchanged state if mordicus tries to move out of bound', () => {
    const state = {
      ...mockState,
      grid: [['üòÆ']] as GridType,
    };

    for (const dir of Directions.all) {
      expect(Logic.getActiveMoveResult(state, dir)).toStrictEqual(state);
    }
  });

  it('should return an unchanged state if mordicus is blocked by an unmoveable unit', () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', 'üêî', '‚¨õ', '‚¨õ'],
      ['‚¨õ', 'üêî', 'üòÆ', 'üêî', '‚¨õ'],
      ['‚¨õ', '‚¨õ', 'üêî', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
    ] as TestGridType;

    for (const blocker of Units.moveBlockers) {
      for (const dir of Directions.all) {
        const state = {
          ...mockState,
          grid: getGridWithChickensReplaced(startGrid, blocker),
        };

        expect(Logic.getActiveMoveResult(state, dir)).toStrictEqual(state);
      }
    }
  });

  it(`should return an unchanged state if there's a grid boundary directly behind moveable units`, () => {
    const startGrid = [
      ['‚¨õ', 'üêî', '‚¨õ'],
      ['üêî', 'üòÆ', 'üêî'],
      ['‚¨õ', 'üêî', '‚¨õ'],
    ] as TestGridType;

    for (const unit of Units.moveables) {
      for (const dir of Directions.all) {
        const state = {
          ...mockState,
          grid: getGridWithChickensReplaced(startGrid, unit),
        };

        expect(Logic.getActiveMoveResult(state, dir)).toStrictEqual(state);
      }
    }
  });

  it(`should return an unchanged state if there's a grid boundary directly behind an arrow`, () => {
    const startGrid = [
      ['üü•', 'üü•', '‚¨ÜÔ∏è', 'üü•', 'üü•'],
      ['üü•', 'üü•', '‚¨áÔ∏è', 'üü•', 'üü•'],
      ['‚¨áÔ∏è', '‚¨ÜÔ∏è', 'üòÆ', '‚¨ÖÔ∏è', '‚û°Ô∏è'],
      ['üü•', 'üü•', '‚¨ÖÔ∏è', 'üü•', 'üü•'],
      ['üü•', 'üü•', '‚û°Ô∏è', 'üü•', 'üü•'],
    ] as GridType;

    for (const dir of Directions.all) {
      const state = {
        ...mockState,
        grid: startGrid,
      };

      expect(Logic.getActiveMoveResult(state, dir)).toStrictEqual(state);
    }
  });

  it(`should return an unchanged state if there's a push blocking unit directly behind moveable units`, () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üêî', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', 'üêî', '‚¨ÜÔ∏è', 'üü©', 'üçå', 'üòÆ', 'üçå', 'üü©', '‚¨áÔ∏è', 'üêî', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üêî', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
    ] as TestGridType;

    for (const pushBlocker of Units.pushBlockers) {
      for (const dir of Directions.all) {
        const state = {
          ...mockState,
          grid: getGridWithChickensReplaced(startGrid, pushBlocker),
        };

        expect(Logic.getActiveMoveResult(state, dir)).toStrictEqual(state);
      }
    }
  });

  it('should execute the move and gather any coins mordicus moves on', () => {
    const startGrid = [
      ['üü°', 'üü°', 'üü°'],
      ['üòÆ', 'üü°', 'üü°'],
    ] as GridType;

    const sequence: {
      dir: DirectionType;
      grid: GridType;
    }[] = [
      {
        dir: 'ArrowUp',
        grid: [
          ['üòÆ', 'üü°', 'üü°'],
          ['‚¨õ', 'üü°', 'üü°'],
        ] as GridType,
      },
      {
        dir: 'ArrowRight',
        grid: [
          ['‚¨õ', 'üòÆ', 'üü°'],
          ['‚¨õ', 'üü°', 'üü°'],
        ] as GridType,
      },
      {
        dir: 'ArrowRight',
        grid: [
          ['‚¨õ', '‚¨õ', 'üòÆ'],
          ['‚¨õ', 'üü°', 'üü°'],
        ] as GridType,
      },
      {
        dir: 'ArrowDown',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', 'üü°', 'üòÆ'],
        ] as GridType,
      },
      {
        dir: 'ArrowLeft',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
        ] as GridType,
      },
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getActiveMoveResult(accState, currTest.dir);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest.grid,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it('should execute the move if mordicus moves to an empty space', () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ'],
      ['üòÆ', '‚¨õ'],
    ] as GridType;

    const sequence: {
      dir: DirectionType;
      grid: GridType;
    }[] = [
      {
        dir: 'ArrowUp',
        grid: [
          ['üòÆ', '‚¨õ'],
          ['‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowRight',
        grid: [
          ['‚¨õ', 'üòÆ'],
          ['‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowDown',
        grid: [
          ['‚¨õ', '‚¨õ'],
          ['‚¨õ', 'üòÆ'],
        ] as GridType,
      },
      {
        dir: 'ArrowLeft',
        grid: [
          ['‚¨õ', '‚¨õ'],
          ['üòÆ', '‚¨õ'],
        ] as GridType,
      },
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getActiveMoveResult(accState, currTest.dir);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest.grid,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it(`should push the rows of units forward if they are moveable units and there's at least one empty space behind them`, () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', 'üçå', 'üü©', '‚¨ÖÔ∏è', '‚¨õ'],
      ['‚¨õ', '‚û°Ô∏è', 'üü©', 'üçå', 'üòÆ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
    ] as GridType;

    const sequence: {
      dir: DirectionType;
      grid: GridType;
    }[] = [
      {
        dir: 'ArrowUp',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üòÆ', 'üçå', 'üü©', '‚¨ÖÔ∏è', '‚¨õ'],
          ['‚¨õ', '‚û°Ô∏è', 'üü©', 'üçå', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowRight',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üòÆ', 'üçå', 'üü©', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚û°Ô∏è', 'üü©', 'üçå', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowDown',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', 'üü©', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚û°Ô∏è', 'üü©', 'üçå', '‚¨õ', 'üòÆ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowLeft',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', 'üü©', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚û°Ô∏è', 'üü©', 'üçå', 'üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
      },
      {
        dir: 'ArrowLeft',
        grid: [
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', 'üü©', '‚¨ÖÔ∏è'],
          ['‚û°Ô∏è', 'üü©', 'üçå', 'üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', 'üü©', '‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
      },
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getActiveMoveResult(accState, currTest.dir);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest.grid,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it(`should not immediately move arrows freed following mordicus' move`, () => {
    const moves: {
      startGrid: GridType;
      dir: DirectionType;
      expected: GridType;
    }[] = [
      {
        startGrid: [
          ['‚¨õ', '‚¨õ', '‚¨õ'],
          ['‚û°Ô∏è', 'üòÆ', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
        dir: 'ArrowUp',
        expected: [
          ['‚¨õ', 'üòÆ', '‚¨õ'],
          ['‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
      },
      {
        startGrid: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['‚û°Ô∏è', 'üòÆ', '‚¨õ'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
        dir: 'ArrowRight',
        expected: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['‚û°Ô∏è', '‚¨õ', 'üòÆ'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
      },
      {
        startGrid: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['‚û°Ô∏è', 'üòÆ', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚¨õ', '‚¨õ'],
        ] as GridType,
        dir: 'ArrowDown',
        expected: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è'],
          ['‚¨õ', 'üòÆ', '‚¨õ'],
        ] as GridType,
      },
      {
        startGrid: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['‚¨õ', 'üòÆ', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
        dir: 'ArrowLeft',
        expected: [
          ['‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
          ['üòÆ', '‚¨õ', '‚¨ÖÔ∏è'],
          ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
        ] as GridType,
      },
    ];

    for (const { startGrid, dir, expected } of moves) {
      expect(
        Logic.getActiveMoveResult(
          {
            ...mockState,
            grid: startGrid,
          },
          dir,
        ),
      ).toStrictEqual({
        ...mockState,
        grid: expected,
      });
    }
  });
});

describe('getPassiveMovesResult', () => {
  it('should move red gorillas adjacent to mordicus on top of him', () => {
    const startGrid = [
      ['ü¶ç', 'ü¶ç', 'ü¶ç'],
      ['ü¶ç', 'üòÆ', 'ü¶ç'],
      ['ü¶ç', 'ü¶ç', 'ü¶ç'],
    ] as GridType;

    expect(
      Logic.getPassiveMovesResult({
        ...mockState,
        grid: startGrid,
      }),
    ).toStrictEqual({
      ...mockState,
      grid: [
        ['ü¶ç', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', 'ü¶ç', '‚¨õ'],
        ['ü¶ç', '‚¨õ', 'ü¶ç'],
      ] as GridType,
    });
  });

  it('should move and duplicate red gorillas over each banana adjacent to them', () => {
    const startGrid = [
      ['ü¶ç', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'ü¶ç'],
      ['üçå', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', 'üçå'],
      ['üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå'],
      ['üçå', 'üçå', 'üçå', 'üòÆ', 'üçå', 'üçå', 'üçå'],
      ['üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå'],
      ['üçå', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', 'üçå'],
      ['ü¶ç', 'üçå', 'üçå', 'üçå', 'üçå', 'üçå', 'ü¶ç'],
    ] as GridType;

    const sequence: GridType[] = [
      [
        ['‚¨õ', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', '‚¨õ'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['üçå', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', 'üçå'],
        ['üçå', 'üçå', 'üçå', 'üòÆ', 'üçå', 'üçå', 'üçå'],
        ['üçå', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', 'üçå'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', 'ü¶ç', 'üçå', 'üçå', 'üçå', 'ü¶ç', '‚¨õ'],
      ] as GridType,
      [
        ['‚¨õ', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['üçå', 'ü¶ç', 'üçå', 'üòÆ', 'üçå', 'ü¶ç', 'üçå'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', 'ü¶ç', 'üçå', 'ü¶ç', '‚¨õ', '‚¨õ'],
      ] as GridType,
      [
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', 'üòÆ', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as GridType,
      [
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['ü¶ç', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as GridType,
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getPassiveMovesResult(accState);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it('should duplicate red gorillas on the same move both on top of mordicus and the adjacent bananas', () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ'],
      ['‚¨õ', 'üçå', 'ü¶ç', 'üçå', '‚¨õ'],
      ['üçå', 'ü¶ç', 'üòÆ', 'ü¶ç', 'üçå'],
      ['‚¨õ', 'üçå', 'ü¶ç', 'üçå', '‚¨õ'],
      ['‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ'],
    ] as GridType;

    expect(
      Logic.getPassiveMovesResult({
        ...mockState,
        grid: startGrid,
      }),
    ).toStrictEqual({
      ...mockState,
      grid: [
        ['‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ'],
        ['ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç'],
        ['‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ'],
        ['‚¨õ', '‚¨õ', 'ü¶ç', '‚¨õ', '‚¨õ'],
      ] as GridType,
    });
  });

  it('should move blue gorillas adjacent to mordicus on top of him', () => {
    const startGrid = [
      ['üêµ', 'üêµ', 'üêµ'],
      ['üêµ', 'üòÆ', 'üêµ'],
      ['üêµ', 'üêµ', 'üêµ'],
    ] as GridType;

    expect(
      Logic.getPassiveMovesResult({
        ...mockState,
        grid: startGrid,
      }),
    ).toStrictEqual({
      ...mockState,
      grid: [
        ['üêµ', '‚¨õ', 'üêµ'],
        ['‚¨õ', 'üôà', '‚¨õ'],
        ['üêµ', '‚¨õ', 'üêµ'],
      ] as GridType,
    });
  });

  it('should move and duplicate blue gorillas over each banana adjacent to them and then change them into a satiated blue gorilla that stays still', () => {
    const startGrid = [
      ['üêµ', 'üçå', 'üçå', 'üçå', 'üêµ'],
      ['üçå', 'üêµ', 'üçå', 'üêµ', 'üçå'],
      ['üçå', 'üçå', 'üòÆ', 'üçå', 'üçå'],
      ['üçå', 'üêµ', 'üçå', 'üêµ', 'üçå'],
      ['üêµ', 'üçå', 'üçå', 'üçå', 'üêµ'],
    ] as GridType;

    const sequence: GridType[] = [
      [
        ['‚¨õ', 'üôà', 'üçå', 'üôà', '‚¨õ'],
        ['üôà', '‚¨õ', 'üôà', '‚¨õ', 'üôà'],
        ['üçå', 'üôà', 'üòÆ', 'üôà', 'üçå'],
        ['üôà', '‚¨õ', 'üôà', '‚¨õ', 'üôà'],
        ['‚¨õ', 'üôà', 'üçå', 'üôà', '‚¨õ'],
      ] as GridType,
      [
        ['‚¨õ', 'üôà', 'üçå', 'üôà', '‚¨õ'],
        ['üôà', '‚¨õ', 'üôà', '‚¨õ', 'üôà'],
        ['üçå', 'üôà', 'üòÆ', 'üôà', 'üçå'],
        ['üôà', '‚¨õ', 'üôà', '‚¨õ', 'üôà'],
        ['‚¨õ', 'üôà', 'üçå', 'üôà', '‚¨õ'],
      ] as GridType,
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getPassiveMovesResult(accState);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it('should duplicate blue gorillas on the same move both on top of mordicus and the adjacent bananas', () => {
    const startGrid = [
      ['‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ'],
      ['‚¨õ', 'üçå', 'üêµ', 'üçå', '‚¨õ'],
      ['üçå', 'üêµ', 'üòÆ', 'üêµ', 'üçå'],
      ['‚¨õ', 'üçå', 'üêµ', 'üçå', '‚¨õ'],
      ['‚¨õ', '‚¨õ', 'üçå', '‚¨õ', '‚¨õ'],
    ] as GridType;

    expect(
      Logic.getPassiveMovesResult({
        ...mockState,
        grid: startGrid,
      }),
    ).toStrictEqual({
      ...mockState,
      grid: [
        ['‚¨õ', '‚¨õ', 'üôà', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'üôà', '‚¨õ', 'üôà', '‚¨õ'],
        ['üôà', '‚¨õ', 'üôà', '‚¨õ', 'üôà'],
        ['‚¨õ', 'üôà', '‚¨õ', 'üôà', '‚¨õ'],
        ['‚¨õ', '‚¨õ', 'üôà', '‚¨õ', '‚¨õ'],
      ] as GridType,
    });
  });

  it('should move free arrows one move after they are freed', () => {
    const startGrid = [
      ['‚¨áÔ∏è', '‚¨õ', '‚¨õ', 'ü¶ç', '‚¨ÖÔ∏è'],
      ['ü¶ç', 'üçå', '‚¨õ', 'üçå', '‚¨õ'],
      ['‚¨õ', '‚¨õ', 'üòÆ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', 'üçå', '‚¨õ', 'üçå', 'ü¶ç'],
      ['‚û°Ô∏è', 'ü¶ç', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è'],
    ] as GridType;

    const sequence: GridType[] = [
      [
        ['‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÖÔ∏è'],
        ['‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ'],
        ['‚¨õ', '‚¨õ', 'üòÆ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ'],
        ['‚û°Ô∏è', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è'],
      ] as GridType,
      [
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ'],
        ['‚¨áÔ∏è', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨õ'],
        ['‚¨õ', '‚¨õ', 'üòÆ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'ü¶ç', '‚¨õ', 'ü¶ç', '‚¨ÜÔ∏è'],
        ['‚¨õ', '‚û°Ô∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as GridType,
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getPassiveMovesResult(accState);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it('should move free arrows until they face the grid boundary', () => {
    const startGrid = [
      ['‚¨áÔ∏è', '‚¨õ', '‚¨ÖÔ∏è'],
      ['‚¨õ', 'üòÆ', '‚¨õ'],
      ['‚û°Ô∏è', '‚¨õ', '‚¨ÜÔ∏è'],
    ] as GridType;

    const sequence: GridType[] = [
      [
        ['‚¨õ', '‚¨ÖÔ∏è', '‚¨õ'],
        ['‚¨áÔ∏è', 'üòÆ', '‚¨ÜÔ∏è'],
        ['‚¨õ', '‚û°Ô∏è', '‚¨õ'],
      ] as GridType,
      [
        ['‚¨ÖÔ∏è', '‚¨õ', '‚¨ÜÔ∏è'],
        ['‚¨õ', 'üòÆ', '‚¨õ'],
        ['‚¨áÔ∏è', '‚¨õ', '‚û°Ô∏è'],
      ] as GridType,
      [
        ['‚¨ÖÔ∏è', '‚¨õ', '‚¨ÜÔ∏è'],
        ['‚¨õ', 'üòÆ', '‚¨õ'],
        ['‚¨áÔ∏è', '‚¨õ', '‚û°Ô∏è'],
      ] as GridType,
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getPassiveMovesResult(accState);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });

  it('should move free arrows until they face any non empty, non arrow unit', () => {
    const startGrid = [
      ['üòÆ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚û°Ô∏è', '‚¨õ', '‚¨õ', 'üêî', '‚¨õ', '‚¨õ', '‚¨ÖÔ∏è'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
    ] as TestGridType;

    const sequence: TestGridType[] = [
      [
        ['üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚û°Ô∏è', '‚¨õ', 'üêî', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as TestGridType,
      [
        ['üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚û°Ô∏è', 'üêî', '‚¨ÖÔ∏è', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as TestGridType,
      [
        ['üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚û°Ô∏è', 'üêî', '‚¨ÖÔ∏è', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as TestGridType,
    ];

    const arrowsAndEmpty = [...Units.arrows, '‚¨õ'];
    const noArrowsOrEmpty = Units.all.filter(
      (unit) => !arrowsAndEmpty.some((arrowOrEmpty) => arrowOrEmpty === unit),
    );
    for (const unit of noArrowsOrEmpty) {
      sequence.reduce(
        (accState, currTest) => {
          const result = Logic.getPassiveMovesResult(accState);
          expect(result).toStrictEqual({
            ...mockState,
            grid: getGridWithChickensReplaced(currTest, unit),
          });

          return result;
        },
        {
          ...mockState,
          grid: getGridWithChickensReplaced(startGrid, unit),
        } as StateSnapshot,
      );
    }
  });

  it('should change arrows moving on top of each other into red blocks', () => {
    const startGrid = [
      ['üòÆ', '‚¨áÔ∏è', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨áÔ∏è', '‚¨õ'],
      ['‚û°Ô∏è', '‚¨õ', '‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ', '‚¨ÖÔ∏è'],
      ['‚û°Ô∏è', '‚¨áÔ∏è', '‚¨ÖÔ∏è', '‚¨áÔ∏è', '‚¨áÔ∏è', '‚¨áÔ∏è', '‚¨áÔ∏è'],
      ['‚û°Ô∏è', '‚¨õ', '‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ', '‚¨ÖÔ∏è'],
      ['‚û°Ô∏è', '‚¨ÜÔ∏è', '‚¨ÖÔ∏è', '‚¨ÜÔ∏è', '‚¨ÜÔ∏è', '‚¨ÜÔ∏è', '‚¨ÜÔ∏è'],
      ['‚û°Ô∏è', '‚¨õ', '‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ', '‚¨ÖÔ∏è'],
      ['‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ'],
    ] as GridType;

    const sequence: GridType[] = [
      [
        ['üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ'],
        ['‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ', '‚¨áÔ∏è', '‚¨õ', '‚¨áÔ∏è'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ'],
        ['‚û°Ô∏è', '‚¨õ', '‚¨ÖÔ∏è', '‚¨õ', '‚¨ÜÔ∏è', '‚¨õ', '‚¨ÜÔ∏è'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as GridType,
      [
        ['üòÆ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ'],
        ['‚¨õ', 'üü•', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', 'üü•', 'üü•', 'üü•'],
        ['‚¨õ', 'üü•', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
        ['‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ', 'üü•', '‚¨õ'],
        ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'],
      ] as GridType,
    ];

    sequence.reduce(
      (accState, currTest) => {
        const result = Logic.getPassiveMovesResult(accState);
        expect(result).toStrictEqual({
          ...mockState,
          grid: currTest,
        });

        return result;
      },
      {
        ...mockState,
        grid: startGrid,
      } as StateSnapshot,
    );
  });
});
